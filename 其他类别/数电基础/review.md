# C 强制类型转换

## 一、强制类型转换目的、基本格式: 

### 1.1、强转目的

C语言是强类型语言, 如果一个运算符两遍的运算数据类型不同, 先要将其转换为相同的类型, 强制类型转换可以消除程序中的警告, 即确保写代码的程序员自己清楚类型转换, 允许丢失一定精度, 或做类型匹配. 

例如: 

``` c
// 1、丢失精度情况
int main(void)
{
    float f=5.75;
    printf("f=%d,f=%f\n",(int)f,f);
}
// 结果: f=5,f=5.750000

// 2、做类型匹配
int main(void)
{
    int a[5] = {1, 2, 3, 4, 5};
    int *p = (int *)(&a + 1);
    printf("*(p-1) = %d.\n", *(p-1));
}
// 结果: *(p-1) = 5
// 这里面&a + 1中+1,地址加sizeof(a)即一个数组长度
// （int *）将指向数组类型指针, 转换为指向整形, 赋值运算符左右对应
```

### 1.2、C中强转的基本格式

方法比较简单, 如下所示: 

``` c
TYPE1 A;
TYPE2 B;
A = (TYPE1)B; // 强制转换. 
```

## 二、C中变量的本质含义: 

(1) c中所有类型的数据存储在内存中, 都是按照二进制格式存储的. 所以内存中只知道有0和1, 不知道是int的、还是float的还是其他类型. 

(2) int、char、short等属于整形, 他们的存储方式（数转换成二进制往内存中放的方式）是相同的, 只是内存格子大小不同（所以这几种整形就彼此叫二进制兼容格式）；而float和double的存储方式彼此不同, 和整形更不同. 

(3) C语言中的数据类型的本质, 就是决定了这个数在内存中怎么存储的问题, 也就是决定了这个数如何转成二进制的问题. 一定要记住的一点是内存只是存储1010的序列, 而不管这些1010怎么解析. 所以要求我们平时数据类型存取一致. 

int a =5;

存放: 编译器给a分配4字节空间, 并且将5按照int类型的存储方式转成二进制存到a所对应的内存空间中去（a做左值的）；

取值: 我们printf去打印a的时候（a此时做右值）, printf内部的vsprintf函数会按照格式化字符串（就是printf传参的第一个字符串参数中的%d之类的东西）所代表的类型去解析a所对应的内存空间, 解析出的值用来输出. 

解析规则:存进去时是按照这个变量本身的数据类型来存储的（譬如本例中a为int所以按照int格式来存储）；但是取出来时是按照printf中%d之类的格式化字符串的格式来提取的. 此时虽然a所代表的内存空间中的10101序列并没有变（内存是没被修改的）但是怎么理解（怎么把这些1010转成数字）就不一定了. 譬如我们用%d来解析, 那么还是按照int格式解析则值自然还是5；但是如果用%f来解析, 则printf就以为a对应的内存空间中存储的是一个float类型的数, 会按照float类型来解析, 值自然是很奇怪的一个数字了. 

``` c
//数据类型存取差异
int main(void)
{
    //1、按照int类型存却按照float类型取 一定会出错
    int a = 5;
    printf("a = %d.\n", a);     // 5
    printf("a = %f.\n", a);     // 0.000000


    //2、按照int类型存却按照char类型取, 

    int a = 6;
    char *p1 = &a;
    printf("*p1 = %d.\n", *p1);        //6在char范围, 未出错

    short *p2 = &a;        
    printf("*p2 = %d.\n", *p2);        //6


    int a = 66666;
    char *p1 = &a;
    printf("*p1 = %d.\n", *p1);        //106超出char与short范围出错

    short *p2 = &a;        
    printf("*p2 = %d.\n", *p2);        //1130

}
```

小结: 

(1)int和char类型都是整形, 类型兼容的. 所以互转的时候有时候错有时候对. 

(2)int和char的不同在于char只有1个字节而int有4个字节, 所以int的范围比char大. 在char所表示的范围之内int和char是可以互转的不会出错；但是超过了char的范围后char转成int不会错（向大方向转就不会错, 就好比拿小瓶子的水往大瓶子倒不会漏掉不会丢掉）, 而从int到char转就会出错（就好象拿大瓶子水往小瓶子倒一样）

## 三、普通变量强转规则: 

### 3.1、普通变量转换规则

当较低类型的数据转换为较高类型时, 一般只是形式上有所改变,  而不影响数据的实质内容,  而较高类型的数据转换为较低类型时则可能有些数据丢失. 如果一个运算符两边的运算数类型不同, 先要将其转换为相同的类型, 即将运算符右侧数值转换为运算符左侧类型, 同侧低精度类型转换为高精度类型, 然后再参加运算, 转换规则如下图所示. 

```
double ← ── float 高
↑
long
↑
unsigned
↑
int ← ── char,short 低
```

横向箭头表示必须的转换, 如两个float型数参加运算, 虽然它们类型相同, 但仍要先转成double型再进行运算, 结果亦为double型. 

纵向箭头表示当运算符两边的运算数为不同类型时的转换, 如一个long 型数据与一个int型数据一起运算, 需要先将int型数据转换为long型, 然后两者再进行运算, 这些转换可以说是自动的, 但尽量（确保自己允许转换发生）使用以显式的形式强制转换类型的机制. 

### 3.2、具体转换细节

#### (1) 浮点型与整型

将浮点数(单双精度)转换为整数时, 将**舍弃浮点数的小数部分, 只保留整数部分**, 即意译, 内部存储方式改变.

将整型值赋给浮点型变量, 数值不变, 只将形式改为浮点形式, 即小数点后带若干个0. 

注意: 赋值时的类型转换实际上是强制的.

使用函数

``` c++
void show_float_hex(float f) {
    int *p = (int *)&f;
    cout << f << " : " << hex << *p << endl;
}
```

可以查看 float 类型对应的真实十六进制机器码.

#### (2) 单、双精度浮点型

由于 c 语言中的浮点值总是用双精度表示的, 所以 float 型数据只是在尾部加 0 延长为 double 型数据参加运算, 然后直接赋值. 

double 型数据转换为 float 型时, 通过截尾数来实现, 截断前要进行四舍五入操作. 

#### (3) char型与int型

int 型数值赋给 char 型变量时, 只保留其最低8位, 高位部分舍弃.

char 型数值赋给 int 型变量时, 一些编译程序不管其值大小都作正数处理, 而另一些编译程序在转换时, 若 char 型数据值大于 127, 就作为负数处理. 对于使用者来讲, 如果原来char型数据取正值, 转换后仍为正值; 如果原来char型值可正可负, 则转换后也仍然保持原值, 只是数据的内部表示形式有所不同. 

#### (4) int型与long型

long 型数据赋给 int 型变量时, 将低 16 位值送给 int 型变量, 而将高 16 位截断舍弃. (这里假定int型占两个字节). 将 int 型数据送给 long 型变量时, 其外部值保持不变, 而内部形式有所改变.

#### (5) 无符号整数

将一个unsigned型数据赋给一个占据同样长度存储单元的整型变量时(如: unsigned→int、unsigned long→long, unsigned short→short) , 原值照赋, 内部的存储方式不变, 但外部值却可能改变.

用强制类型转换是一个好习惯, 这样, 至少从程序上可以看出想干什么. 

#### (6) 总结

**与浮点数相关**的强制类型转换全都为**意译**, 具体表现为, 整形转浮点型为在整形末尾加零 `1 --> 1.0`, 浮点型转整形截断 `1.5 --> 1`; 单精度转双精度末尾加零 `1.5 --> 1.50`, 双精度转单精度四舍五入 `1.55 -> 1.5`. 注意, **在这个过程中数值的机器码均发生了改变**. (当然精度不可能那么低, 这里的值均为举例, 不是真实的值转换)

**与整形相关**的类型转换中, 长整数类型转换为短整数类型均为**直接截断的直译**, 例如 4 位的 int 转为 2 位的 int 的情况: `1ffff --> ffff`, 前者为 `131071`, 后者为 `-1`; 而短整数类型转长整数类型, 需要分为**无符号和有符号两种情况**, **无符号**的短整数类型可以直接**直译**照搬到长整数类型中, 如 unsigned short 转为 int: `ffff --> 0ffff`; 对于**有符号**的短整数型, 要进行一点**意译**, **正数**时的情况和无符号一样, **机器码不变**, 但是**负数**的短整数, 在转换后仍为负数, 此时**机器码改变**, 例如 unsigned short 转为 int: `ffff --> ffffffff`, 即 `-1 --> -1`.

**PS: 在多种类型参与运算时, 会自动强制类型转化为参与类型中的最高类型, 再继续运算.**

## 四、指针变量强转规则: 

(1)指针变量强转, 改变了指针取址能力. 

(2)一个指针涉及2个变量: 一个是指针变量自己本身, 一个是指针变量指向的那个变量

(3)int p;定义指针变量时, p（指针变量本身）是int 类型, *p（指针指向的那个变量）是int类型的. 

(4)int 类型说白了就是指针类型, 只要是指针类型就都是占4字节, 解析方式都是按照地址的方式来解析（意思是里面存的32个二进制加起来表示一个内存地址）的. 结论就是: 所有的指针类型（不管是int 还是char * 还是double *）的解析方式是相同的, 都是地址. 

(5)对于指针所指向的那个变量来说, 指针的类型就很重要了. 指针所指向的那个变量的类型（它所对应的内存空间的解析方法）要取决于指针类型. 譬如指针是int *的, 那么指针所指向的变量就是int类型的. 

```
#include <stdio.h>
int main(void)
{

    int a[3] = {0x11223344, 0x55667788, 0};

    int *p1 = a;
    printf("*p1 = 0x%x\n", *p1);         //*p1 = 0x11223344

    char *p2 = (char *)a;              //改变取址能力         
    printf("*p2 = 0x%x\n", *p2);      //*p2 = 0x44
    printf("*p2 = 0x%x\n", *(p2+1));   //*p2 = 0x33
    printf("*p2 = 0x%x\n", *(p2+2));   //*p2 = 0x22
    printf("*p2 = 0x%x\n", *(p2+3));   //*p2 = 0x11
    printf("*p2 = 0x%x\n", *(p2+4));   //*p2 = 0xffffff88 ？
    printf("*p2 = 0x%x\n", *(p2+5));  //*p2 = 0x77

    return 0;
}
```

## 五、逻辑移位

**逻辑左移和逻辑右移**都是空缺处补 `0`.  

**算术左移**同逻辑左移.

**算术右移**移入的位用符号位填, 即负数最高位填 `1`, 正数最高位填 `0`.

一般来说, 无符号数移位用逻辑移位, 有符号数用算术移位.
