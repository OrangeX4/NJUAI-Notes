# Solution for Problem Set 4

## Problem 1

**(a)**

1. $\left<5, 13, 2, {\color{red} 25}, 7, 17, 20, {\color{red} 15, 4}\right>$
2. $\left<5, 13, 2, {\color{red} 25}, 7, 17, 20, {\color{red} 15, 4}\right>$
3. $\left<5, {\color{red} 13}, 2, {\color{red} 25, 7}, 17, 20, 15, 4\right>$
4. $\left<5, {\color{red} 25}, 2, {\color{red} 13, 7}, 17, 20, 15, 4\right>$
5. $\left<5, 25, 2, {\color{red} 13}, 7, 17, 20, {\color{red} 15, 4}\right>$
6. $\left<5, 25, 2, {\color{red} 15}, 7, 17, 20, {\color{red} 13, 4}\right>$
7. $\left<5, 25, {\color{red} 2}, 15, 7, {\color{red} 17, 20}, 13, 4\right>$
8. $\left<5, 25, {\color{red} 20}, 15, 7, {\color{red} 17, 2}, 13, 4\right>$
9. $\left<{\color{red} 5, 25, 20}, 15, 7, 17, 2, 13, 4\right>$
10. $\left<{\color{red} 25, 5, 20}, 15, 7, 17, 2, 13, 4\right>$
11. $\left<25, {\color{red} 5}, 20, {\color{red} 15, 7}, 17, 2, 13, 4\right>$
12. $\left<25, {\color{red} 15}, 20, {\color{red} 5, 7}, 17, 2, 13, 4\right>$
13. $\left<25, 15, {\color{red} 20}, 5, 7, {\color{red} 17, 2}, 13, 4\right>$
14. $\left<25, 15, {\color{red} 20}, 5, 7, {\color{red} 17, 2}, 13, 4\right>$
15. $\left<25, 15, 20, {\color{red} 5}, 7, 17, 2, {\color{red} 13, 4}\right>$
16. $\left<25, 15, 20, {\color{red} 13}, 7, 17, 2, {\color{red} 5, 4}\right>$

**(b)**

1.  $\left<{\color{red} 25}, 15, 20, 13, 7, 17, 2, 5, {\color{red} 4}\right>$
2.  $\left<{\color{red} 4}, 15, 20, 13, 7, 17, 2, 5, {\color{blue} 25}\right>$
3.  $\left<{\color{red} 4, 15, 20}, 13, 7, 17, 2, 5, {\color{blue} 25}\right>$
4.  $\left<{\color{red} 20, 15, 4}, 13, 7, 17, 2, 5, {\color{blue} 25}\right>$
5.  $\left<20, 15, {\color{red} 4}, 13, 7, {\color{red} 17, 2}, 5, {\color{blue} 25}\right>$
6.  $\left<20, 15, {\color{red} 17}, 13, 7, {\color{red} 4, 2}, 5, {\color{blue} 25}\right>$
7.  $\left<{\color{red} 20}, 15, 17, 13, 7, 4, 2, {\color{red} 5}, {\color{blue} 25}\right>$
8.  $\left<{\color{red} 5}, 15, 17, 13, 7, 4, 2, {\color{blue} 20, 25}\right>$
9.  $\left<{\color{red} 5, 15, 17}, 13, 7, 4, 2, {\color{blue} 20, 25}\right>$
10.  $\left<{\color{red} 17, 15, 5}, 13, 7, 4, 2, {\color{blue} 20, 25}\right>$
11.  $\left<17, 15, {\color{red} 5}, 13, 7, {\color{red} 4, 2}, {\color{blue} 20, 25}\right>$
12.  $\left<17, 15, {\color{red} 5}, 13, 7, {\color{red} 4, 2}, {\color{blue} 20, 25}\right>$
13. $\left<{\color{red} 17}, 15, 5, 13, 7, 4, {\color{red} 2}, {\color{blue} 20, 25}\right>$
14. $\left<{\color{red} 2}, 15, 5, 13, 7, 4, {\color{blue} 17, 20, 25}\right>$
15. $\left<{\color{red} 2, 15, 5}, 13, 7, 4, {\color{blue} 17, 20, 25}\right>$
16. $\left<{\color{red} 15, 2, 5}, 13, 7, 4, {\color{blue} 17, 20, 25}\right>$
17. $\left<15, {\color{red} 2}, 5, {\color{red} 13, 7}, 4, {\color{blue} 17, 20, 25}\right>$
18. $\left<15, {\color{red} 13}, 5, {\color{red} 2, 7}, 4, {\color{blue} 17, 20, 25}\right>$
19. $\left<{\color{red} 15}, 13, 5, 2, 7, {\color{red} 4}, {\color{blue} 17, 20, 25}\right>$
20. $\left<{\color{red} 4}, 13, 5, 2, 7, {\color{blue} 15, 17, 20, 25}\right>$
21. $\left<{\color{red} 4, 13, 5}, 2, 7, {\color{blue} 15, 17, 20, 25}\right>$
22. $\left<{\color{red} 13, 4, 5}, 2, 7, {\color{blue} 15, 17, 20, 25}\right>$
23. $\left<13, {\color{red} 4}, 5, {\color{red} 2, 7}, {\color{blue} 15, 17, 20, 25}\right>$
24. $\left<13, {\color{red} 7}, 5, {\color{red} 2, 4}, {\color{blue} 15, 17, 20, 25}\right>$
25. $\left<{\color{red} 13}, 7, 5, 2, {\color{red} 4}, {\color{blue} 15, 17, 20, 25}\right>$
26. $\left<{\color{red} 4}, 7, 5, 2, {\color{blue} 13, 15, 17, 20, 25}\right>$
27. $\left<{\color{red} 4, 7, 5}, 2, {\color{blue} 13, 15, 17, 20, 25}\right>$
28. $\left<{\color{red} 7, 4, 5}, 2, {\color{blue} 13, 15, 17, 20, 25}\right>$
29. $\left<7, {\color{red} 4}, 5, {\color{red} 2}, {\color{blue} 13, 15, 17, 20, 25}\right>$
30. $\left<7, {\color{red} 4}, 5, {\color{red} 2}, {\color{blue} 13, 15, 17, 20, 25}\right>$
31. $\left<{\color{red} 7}, 4, 5, {\color{red} 2}, {\color{blue} 13, 15, 17, 20, 25}\right>$
32. $\left<{\color{red} 2}, 4, 5, {\color{blue} 7, 13, 15, 17, 20, 25}\right>$
33. $\left<{\color{red} 2, 4, 5}, {\color{blue} 7, 13, 15, 17, 20, 25}\right>$
34. $\left<{\color{red} 5, 4, 2}, {\color{blue} 7, 13, 15, 17, 20, 25}\right>$
35. $\left<{\color{red} 5}, 4, {\color{red} 2}, {\color{blue} 7, 13, 15, 17, 20, 25}\right>$
36. $\left<{\color{red} 2}, 4, {\color{blue} 5, 7, 13, 15, 17, 20, 25}\right>$
37. $\left<{\color{red} 2, 4}, {\color{blue} 5, 7, 13, 15, 17, 20, 25}\right>$
38. $\left<{\color{red} 4, 2}, {\color{blue} 5, 7, 13, 15, 17, 20, 25}\right>$
39. $\left<{\color{red} 4, 2}, {\color{blue} 5, 7, 13, 15, 17, 20, 25}\right>$
40. $\left<{\color{blue} 2, 4, 5, 7, 13, 15, 17, 20, 25}\right>$


## Problem 2

**Overview:**

Create a list called $L$ and build a maximum heap $H$ with $k$ largest elements from $k$ sorted lists. In $n$-loop, extract maximum from the heap and save it to the array $L$, then add new element from the list where extracted maximum existed to the heap. Finally we get a sorted list $L$.

**Algorithm:**

Let $k$ sorted lists called $S$. We assert that the lists are arranged from small to large.

<pre class="pseudocode">
\begin{algorithm}
\caption{Sort}
\begin{algorithmic}

\FUNCTION{Sort}{$S$}
    \STATE Let $L$ be a new empty list, $H$ be a new empty heap
    \FOR{i = 1 \TO k}
        \STATE $H$.insert($S$[i].removeLast())
    \ENDFOR
    \FOR{i = 1 \TO n}
        \STATE x = $H$.extractMax()
        \STATE $L$.addToHead(x)
        \STATE Let $T$ be the original list of $x$
        \IF{$T$ is not empty}
            \STATE $H$.insert($T$.removeLast())
        \ENDIF
    \ENDFOR
    \RETURN $L$
\ENDFUNCTION

\end{algorithmic}
\end{algorithm}
</pre>

**Time Complexity:**

The first loop be executed $k$ times and each times be executed in time $O(\log k)$ of $H$.insert(). The total time of the first loop is $O(k\log k)$

The first loop be executed $n$ times and each times be executed in time $O(\log k)$ of $H$.extractMax() and $H$.insert(). The total time of the first loop is $O(n\log k)$

$T(n)=c_0+O(k\log k)+O(n\log k)=O(n\log k)$


## Problem 3

**(a)**

We assume for this problem that the input size $n$ is always a power of 2.

We prove that after the function `Unusual()` the array will be sorted. And the two subarrays $A[1...n/2]$ and $A[n/2+1...n]$ of input array $A[1...n]$ of `Unusual()` are both sorted.

**Basis:** When $n = 2$, the subarrays $A[1]$ and $A[2]$ are both sorted normally, and after swap operation, the new array $A'[1,2]$ are sorted.

**I.H:** The array $A[1...n/2]$ and $A[n/2+1...n]$ are both sorted.

**I.S:**

Before the for-loop, we can know that the array $A[1...n/2]$ and $A[n/2+1...n]$ are both sorted.

So we know that $A[1...n/4] \prec A[n/4+1...n/2]$ and $A[n/2+1...3n/4] \prec A[3n/4+1...n]$ (The sign $A \prec B$ mean that for any element $a$ in $A$, we have that $a$ is smaller than any element $b$ in $B$).

After the for-loop, which swap 2nd and 3rd quarters, we can know that the new subarray $A[1...n/4] \prec A[n/2+1...3n/4]$ and $A[n/4+1...n/2] \prec A[3n/4+1...n]$.

We rename the four parts as $A, B, C, D$, so that $A\prec C$ and $B\prec D$.

After `Unusual(A[1...n/2])` and `Unusual(A[n/2+1...n])`, $A[1...n/2]$ and $A[n/2+1...n]$ are sorted.

Now we prove that the current $A[1...n/4]$ are the smallest part of the four parts.

For any element $e\in A[1...n/4]$, for example, $e \in B$, so we can know that $e \prec A[n/4+1...n/2]$ and $e \prec D$.

Because $e \in A[1...n/4]$ and $e \in B$, so there at least an element $a \in A[n/4+1...n/2]$ and $a \in A$. We know $A \prec C$, so $e \prec A[n/4+1...n/2] \Rightarrow e \leqslant a \Rightarrow e \prec C$.

Finally, we can know that for any element $e$ in $A[1...n/4]$, we have that $e \prec A[n/4+1...n/2]$, $e \prec C$, $e \prec D$. We prove that the current $A[1...n/4]$ are the smallest part of the four parts.

Similarly, we can prove that current $A[3n/4+1...n]$ are the largest part of the four parts.

For `Unusual(A[n/4+1...3n/4])`, because $A[1...n/2]$ and $A[n/2+1...n]$ are both sorted, the $A[n/4+1...n/2]$ and $A[n/2+1...3n/4]$ are both sorted. After the statement, we get the new sorted middle half array $A[n/4+1...3n/4]$.

So finally we can get the sorted array $A[1...n]$.

**(b)**

Let the input array be $A=\left<3, 4, 1, 2\right>$.

After `Cruel(A[1...n/2])` and `Cruel(A[n/2+1...n])`, the array was still $\left<3, 4, 1, 2\right>$.

In the `Unusual(A[1...n])` call, before recursive `Unusual()`, without for-loop, the array was still $\left<3, 4, 1, 2\right>$.

After `Unusual(A[1...n/2])` and `Unusual(A[n/2+1...n])`, the array was still $\left<3, 4, 1, 2\right>$.

After `Unusual(A[n/4+1...3n/4])`, the array became $\left<3, 1, 4, 2\right>$, which was not sorted totally.

So the modified algorithm is not correct.

**(c)**

Let the input array be $A=\left<3, 4, 1, 2\right>$.

After `Cruel(A[1...n/2])` and `Cruel(A[n/2+1...n])`, the array was still $\left<3, 4, 1, 2\right>$.

In the `Unusual(A[1...n])` call, after for-loop, the array became $\left<3, 1, 4, 2\right>$.

After `Unusual(A[1...n/2])`, the array was still $\left<1, 3, 4, 2\right>$.

After `Unusual(A[n/4+1...3n/4])`, the array was still $\left<1, 3, 4, 2\right>$.

After `Unusual(A[n/2+1...n])`, the array became $\left<1, 3, 2, 4\right>$, which was not sorted totally.

So the modified algorithm is not correct.

**(d)**

**Unusual:** $\displaystyle T_1(n)=3T_1(\frac{n}{2})+\frac{n}{4}=O(n^{\log 3})$

**Cruel:** $\displaystyle T_2(n)=2T_2(\frac{n}{2})+T_1(n)$

Because $\displaystyle n^{\log 3} > 2\cdot (\frac{n}{2})^{\log 3}$, the sums of each layer is degressive.

Using master theorem we know:

So $T_{2}(n)=O(n^{\log 3})$


## Problem 4

**(a)**

Using induction.

**Basis:**

There are three basis:

When $p=1$ and $r=n$, the first times of loop and the shallow stack, after $q\leftarrow$ Partition($A, p, r$), we make sure that $A[1...q] \prec A[q+1...n]$.

When $p=r=1$, at the end of first times of loop and the deepest stack, $A[1]$ is sorted (When $p=r=2$, the case is similar).

When $p=r$, the only statement which was execute is $p\leftarrow$ Partition($A,p,r$), It change nothing, and $A[p]$ or $A[r]$ is sorted.

**I.H:**

There are two hypotheses:

At the beginning of each times of loop, the $A[1...p-1]$ is sorted and $A[1...p-1] \prec A[p...n]$.

TRQuickSort($A, p, q-1$) will make $A[p...q-1]$ be sorted.

**I.S:**

Firstly, we prove that at the end of each times of loop, $A[1...q]$ is sorted and $A[1...q] \prec A[q+1...n]$.

For each times of loop, using I.H's first hypothesis, we know the $A[1...p-1]$ is sorted and $A[1...p-1] \prec A[p...n]$.

After $q\leftarrow$ Partition($A,p,r$), we know that $A[p...q-1]\prec A[q]\prec A[q+1...r]$.

Using I.H's second hypothesis, it is that TRQuickSort($A, p, q-1$) will make $A[p...q-1]$ be sorted.

So $A[p...q]$ was sorted after TRQuickSort($A, p, q-1$), and $A[p...q]\prec A[q+1...r]$.

So at the end of each times of loop, $A[1...q]$ is sorted and $A[1...q] \prec A[q+1...n]$.

Secondly, we prove that after all loop, $A[p...r]$ will be sorted.

Because for each times of loop, the $A[1...q]$ is sorted, the final $q$ is $r$ or $r-1$ and $A[1...q]\prec A[q+1...n]$ for each $q$, the $A[p...r]$ will be sorted.

**(b)**

Create an input array $A=\left<1,2,3,...,n\right>$ for TRQuickSort.

As we can see, the $q\leftarrow$ Partition($A,p,r$) didn't change the input array. At the first time, $q=r$.

Then, call `TRQuickSort(A,p,q-1)`, which is same with `TRQuickSort(A,p,r-1)`.

Similarly, the next `TRQuickSort(A,p,r-1)` will call `TRQuickSort(A,p,r-2)`, which divide problem from $n$ into $1$ and $n-1$.

So we can prove that it will call $n$ times `TRQuickSort()`. The stack depth is $\Theta(n)$.

**(c)**

<pre class="pseudocode">
\begin{algorithm}
\caption{ModifiedTRQuickSort}
\begin{algorithmic}

\FUNCTION{ModifiedTRQuickSort}{}
    \WHILE{$p < r$}
        \STATE $q\leftarrow$ Partition($A,p,k$)
        \IF{$q < (p+r) / 2$}
            \STATE TRQuickSort($A,p,q-1$)
            \STATE $p\leftarrow q+1$
        \ELSE
            \STATE TRQuickSort($A,q+1,r$)
            \STATE $r\leftarrow q-1$
        \ENDIF
    \ENDWHILE
\ENDFUNCTION

\end{algorithmic}
\end{algorithm}
</pre>

Why the modification can guarantee $\Theta(\lg n)$ worst-case stack depth?

The TRQuickSort is the modified version QuickSort algorithm, which replaces one recursive call by using an iterative control structure. We can replace the second recursive call, it is obvious that we can replace the first recursive call.

We use a if statement so that we can let the input subarray of TRQuickSort is always the small part of the two parts. In the worst case, we divide the array into two subarrays with same length. We can make sure that it is $\Theta(\lg n)$ worst-case stack depth.


## Problem 5

**(a)**

**Algorithm:**

<pre class="pseudocode">
\begin{algorithm}
\caption{Sort}
\begin{algorithmic}

\FUNCTION{Sort}{$A[1...n]$}
    \FOR{i = $n - \sqrt{n}$ \TO $0$ step $\sqrt{n} / 2$}
        \FOR{j = $0$ \TO i step $\sqrt{n} / 2$}
            \STATE SqrtSort(j)
        \ENDFOR
    \ENDFOR
\ENDFUNCTION

\end{algorithmic}
\end{algorithm}
</pre>

**Correctness:**

It is like a bubble sort. Bubble sort compare and swap two elements in an array. The `Sort` function view $\sqrt{n} / 2$ elements as an element or block.

- Loop invariant: After the $i$-th loop, $A[i+\sqrt{n} / 2...i+\sqrt{n}]$ is the largest block of $A[1...i+\sqrt{n}]$ and $A[i+\sqrt{n} / 2...i+\sqrt{n}]$ is sorted.
- Proof:
  - Initialization: After the first loop, $A[n-\sqrt{n} / 2...n]$ is the largest block and it is sorted.
  - Maintain: After the inner for-loop, the largest block was send to the tail of $A[1...i+\sqrt{n}]$, so $A[i+\sqrt{n} / 2...i+\sqrt{n}]$ is the largest block of $A[1...i+\sqrt{n}]$ and $A[i+\sqrt{n} / 2...i+\sqrt{n}]$ is sorted.
  - Termination: $A[1...n]$ is sorted.

**Time Complexity:**

We calculate the times of we call `SqrtSort`.

$\because \displaystyle \frac{n-\sqrt{n}}{\sqrt{n} / 2}=2\sqrt{n}-2$

$\therefore \displaystyle T(n)=\frac{(1+2\sqrt{n}-2)(2\sqrt{n}-2)}{2}=O(n)$

**(b)**

<pre class="pseudocode">
\begin{algorithm}
\caption{SqrtSort}
\begin{algorithmic}

\FUNCTION{SqrtSort}{k}
    \IF{$\sqrt{n}$ == 1}
        \RETURN $A[k+1]$
    \ELSEIF{$\sqrt{n}$ == 2}
        \IF{$A[k+1]$ > $A[k+2]$}
            \STATE Swap($A[k+1]$, $A[k+2]$)
        \ENDIF
    \ELSE
        \STATE Sort($A[k+1...k+\sqrt{n}]$)
    \ENDIF
\ENDFUNCTION

\end{algorithmic}
\end{algorithm}
</pre>

**Time Complexity:**

$T(2)=\Theta(1)$

$T(n)=n\cdot T(\sqrt{n})$

ä»¤ $m=\lg n$

$\therefore T(2^{m})=2^{m}\cdot T(2^{m/2})$

$\therefore \displaystyle S(m)=m\cdot T(\frac{m}{2})=m\cdot \frac{m}{2}\cdot \frac{m}{2^{2}}\cdot T(\frac{m}{2^{3}})=\frac{m^{\lg m}}{2^0\cdot 2^{1}\cdots 2^{\lg m}}=O(\frac{m^{\lg m}}{2^{(\lg m)^{2}/2}})$

$\therefore \displaystyle T(n)=O(\frac{m^{\lg \lg n}}{2^{(\lg \lg n)^{2}/2}})$


## Problem 6

**(a)**

Let the expected value of `OneInThree()` be $E_a$, the probability of `OneInThree()` returning 1 be $p_a$.

$\therefore \displaystyle E_a = \frac{1}{2}\times 0+\frac{1}{2}\times (1-E_a)$

$\therefore \displaystyle E_a=\frac{1}{3}$

$\because \displaystyle E_a=1\cdot p_a+0\cdot (1-p_a)=p_a$

$\therefore \displaystyle p_a=\frac{1}{3}$

**(b)**

Let the exact expected number of `OneInThree()` be $E_b$.

$\because \displaystyle E_b=\frac{1}{2}\times 1+(\frac{1}{2})^{2}\times 2+(\frac{1}{2})^{3}\times 3+\cdots=\sum_{k=1}^{\infty}(\frac{1}{2})^{k}\cdot k$

$\therefore \displaystyle E_b=\sum_{k=1}^{\infty}(\frac{1}{2})^{k}\cdot k=\frac{1}{2}+\sum_{k=2}^{\infty}(\frac{1}{2})^{k}\cdot k=\frac{1}{2}+\sum_{k=1}^{\infty}(\frac{1}{2})^{k+1}\cdot (k+1)$

$\because \displaystyle \frac{1}{2}E_b=\sum_{k=1}^{\infty}(\frac{1}{2})^{k+1}\cdot k$

$\therefore \displaystyle E_b-\frac{1}{2}E_b=\frac{1}{2}E_b=\frac{1}{2}+\sum_{k=1}^{\infty}(\frac{1}{2})^{k+1}=\sum_{k=1}^{\infty}(\frac{1}{2})^{k}=1$

$\therefore \displaystyle E_b=2$

**(c)**

Let the expected value of `OneInTwo()` be $E_c$, the probability of `BiasedCoin()` returning 1 be $p$.

<pre class="pseudocode">
\begin{algorithm}
\caption{OneInTwo}
\begin{algorithmic}

\FUNCTION{OneInTwo}{}
    \STATE a = BiasedCoin()
    \STATE b = BiasedCoin()
    \IF{(a == 1 \AND b == 1) \OR (a == 0 \AND b == 0)}
        \RETURN OneInTwo()
    \ELSEIF{a == 1 \AND b == 0}
        \RETURN 1
    \ELSEIF{a == 0 \AND b == 1}
        \RETURN 0
    \ENDIF
\ENDFUNCTION

\end{algorithmic}
\end{algorithm}
</pre>

$\because \displaystyle E_c=[p^{2}+(1-p)^{2}]E_c+p(1-p)\cdot 1+p(1-p)\cdot 0$

$\therefore \displaystyle E_c=\frac{1}{2}$

**(d)**

Let the exact expected number of `BiasedCoin()` be $E_d$, $p_d=p^{2}+(1-p)^{2}$.

$\because \displaystyle E_d=(1-p_d)\cdot 0+p_d(1-p_d)\cdot 2+p_d^{2}(1-p_d)\cdot 4+\cdots=2(1-p_d)\sum_{k=1}^{\infty}p_d^{k}\cdot k$

$\therefore \displaystyle E_d=2(1-p_d)\sum_{k=1}^{\infty}p_d^{k}\cdot k=2(1-p_d)[p_d+\sum_{k=2}^{\infty}p_d^{k}\cdot k]=2(1-p_d)[p_d+\sum_{k=1}^{\infty}p_d^{k+1}\cdot (k+1)]$

$\because \displaystyle p_dE_d=2(1-p_d)\sum_{k=1}^{\infty}p_d^{k+1}\cdot k$

$\therefore \displaystyle E_d-p_dE_d=(1-p_d)E_d=2(1-p_d)[p_d+\sum_{k=1}^{\infty}p_d^{k+1}]=2(1-p_d)\sum_{k=1}^{\infty}p_d^{k}$

$\therefore \displaystyle E_d=2\sum_{k=1}^{\infty}p_d^{k}=2\cdot \lim_{n \to \infty}\frac{p_d(1-p_d^{n})}{1-p_d}=\frac{2p_d}{1-p_d}=\frac{- 2 p^{2} + 2 p - 1}{p \left(p - 1\right)}$


## Problem 7

Because $2^{19}=524288<1000000<2^{20}=1048576$, so the number contains 20 bits. So we need asks 20 times for all bits of the number. We assure that the first bit is the lowest bit.

<pre class="pseudocode">
\begin{algorithm}
\caption{Query}
\begin{algorithmic}

\FUNCTION{Query}{}
    \STATE sum = 0
    \FOR{$i$ = 1 \TO 20}
        \IF{query the $i$-th bit == 1}
            \STATE sum = sum + $2^{i-1}$
        \ENDIF
    \ENDFOR
    \RETURN sum
\ENDFUNCTION

\end{algorithmic}
\end{algorithm}
</pre>

So the $T(n)=c_0+c_1\log n+c_2=\Theta(\log n)=20$ times

The the upper bound and lower bound are both $O(\log n)$ or 20 times.

It is obvious that the upper bound is correct.

Prove that the lower bound is correct, too:

Using the adversary argument.

Assure that we only ask $n-1=19$ times, like $?0000000000000000000$. Can we determine the number is zero or $10000000000000000000$ (binary number)?

If we guess the number is zero, the adversary Eve can say that the number is $2^{19}$.

If we guess the number is $2^{19}$, the adversary Eve can say that the number is zero.

And if we use other algorithm like dichotomy, it is also impossible to know the number less than $20$ times question.

So the lower bound is $O(\log n)$ or 20 times.


## Bonus Problem


